<!DOCTYPE html>
<html>
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	
	<!-- Begin Jekyll SEO tag v2.8.0 -->

<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="Simple CRUD for Spring JDBC" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Simple CRUD for Spring JDBC" />
<meta property="og:description" content="Simple CRUD for Spring JDBC" />
<meta property="og:url"
	content="https://spring-jdbc-crud.github.io/simplejdbcmapper" />
<meta property="og:site_name" content="Simple CRUD for Spring JDBC" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title"
	content="A simple wrapper around Spring JDBC libraries that makes database CRUD operations less verbose" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebSite","description":"Simple CRUD for Spring JDBC","headline":"Simple CRUD for Spring JDBC #","name":"Simple CRUD for Spring JDBC","url":"https://spring-jdbc-crud.github.io/simplejdbcmapper"}</script>

<!-- End Jekyll SEO tag -->
    <title>SimpleJdbcMapper</title>
    <link type="text/css" rel="stylesheet" href="assets/css/bootstrap.css"/>
    <link type="text/css" rel="stylesheet" href="assets/css/bootstrap-responsive.css"/>
    <link type="text/css" rel="stylesheet" href="assets/css/pilcrow.css"/>
    <link type="text/css" rel="stylesheet" href="assets/css/hljs-github.min.css"/>
    <link type="text/css" rel="stylesheet" href="assets/css/style.css"/>
    <style>
    body {
      background: url('assets/img/textured_paper.png') repeat top left;
      background-color: #f6f6f6;
    }
    </style>
  </head>
<body>

  <div class="container-fluid">
    <div class="row-fluid">
      <div class="span3"><ul class="nav nav-list">
    <li class="sidebar-header-1"><a href="#simplejdbcmapper">SimpleJdbcMapper</a></li>
    <li class="sidebar-header-2"><a href="#features">Features</a></li>
    <li class="sidebar-header-2"><a href="#example-code">Example code</a></li>
    <li class="sidebar-header-2"><a href="#jdk-and-spring-version-requirements">JDK and Spring version requirements</a></li>
    <li class="sidebar-header-2"><a href="#maven-coordinates">Maven coordinates</a></li>
    <li class="sidebar-header-2"><a href="#spring-bean-configuration-for-simplejdbcmapper">Spring bean configuration for SimpleJdbcMapper</a></li>
    <li class="sidebar-header-2"><a href="#configuring-a-conversionservice">Configuring a ConversionService</a></li>
    <li class="sidebar-header-2"><a href="#annotations">Annotations</a></li>
    <li class="sidebar-header-2"><a href="#configuration-for-auto-assigning-createdby-and-updateby">Configuration for auto assigning @CreatedBy and @UpdateBy</a></li>
    <li class="sidebar-header-2"><a href="#accessing-jdbcclientjdbctemplate">Accessing JdbcClient/JdbcTemplate</a></li>
    <li class="sidebar-header-2"><a href="#logging">Logging</a></li>
    <li class="sidebar-header-2"><a href="#troubleshooting">TroubleShooting</a></li>
</ul>
      </div>
      <div class="span9 main"><h1 id="simplejdbcmapper"><a class="header-link" href="#simplejdbcmapper"></a>SimpleJdbcMapper</h1>
<p>A simple wrapper around Spring JDBC libraries that makes database CRUD operations less verbose. Use it along with Spring JdbcClient/JdbcTemplate. </p>
<p>
	<a href="https://github.com/spring-jdbc-crud/simplejdbcmapper">github</a> |
	<a href="https://spring-jdbc-crud.github.io/simplejdbcmapper/javadoc/index.html">Javadoc</a> |
	<a href="https://github.com/spring-jdbc-crud/spring-crud-with-simplejdbcmapper">Example Application</a>
</p>
<h2 id="features"><a class="header-link" href="#features"></a>Features</h2>
<ol class="list">
<li>One liners for CRUD.</li>
<li>Auto assign properties for models:<ul class="list">
<li>auto assign created on, updated on.</li>
<li>auto assign created by, updated by using an implementation of interface RecordOperatorResolver.</li>
<li>optimistic locking feature for updates.</li>
</ul>
</li>
<li>Helper methods to get the SQL for the mapped objects that can be used with Spring row mappers like BeanPropertyRowMapper, SimplePropertyRowMapper etc.</li>
<li>For transaction management use Spring transactions since its just a wrapper library.</li>
<li>To log the SQL statements use the same SQL logging configurations as Spring. See the logging section further below.</li>
<li>Tested against PostgreSQL, MySQL, Oracle, SQLServer.</li>
<li>Only dependency is Spring JDBC libraries. No other external dependencies.</li>
</ol>
<h2 id="example-code"><a class="header-link" href="#example-code"></a>Example code</h2>
<pre class="hljs"><code> <span class="hljs-comment">//@Table annotation is required</span>
 <span class="hljs-meta">@Table(name=&quot;product&quot;)</span>
 <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span> </span>{
   <span class="hljs-comment">/*
    The @Id annotation is required. It can be of any type.
    @Id(type=IdType.AUTO_GENERATED) - Use for ids which are auto generated by the database. Id value will 
                                      be assigned to the object on insert.
    @Id - The id value will have to be manually set before invoking insert().                                                            
   */</span>
   <span class="hljs-meta">@Id(type=IdType.AUTO_GENERATED)</span>
   <span class="hljs-keyword">private</span> Integer id; 
           
   <span class="hljs-comment">// The &#x27;name&#x27; property will map to &#x27;product_name&#x27; column in database table.</span>
   <span class="hljs-meta">@Column(name=&quot;product_name&quot;)</span>            
   <span class="hljs-keyword">private</span> String name;                    
   
   <span class="hljs-comment">// will map to column &#x27;available_date&#x27; by default using camel case to underscore case naming convention</span>
   <span class="hljs-meta">@Column</span>
   <span class="hljs-keyword">private</span> LocalDateTime availableDate;    
   
   <span class="hljs-comment">// will map to &#x27;price&#x27; column by default</span>
   <span class="hljs-meta">@Column</span>
   <span class="hljs-keyword">private</span> Double price;                   
   
   <span class="hljs-comment">// No annotations for this property so excluded from inserts/updates/queries etc</span>
   <span class="hljs-keyword">private</span> String someNonDatabaseProperty; 
 
   ...
 }

 ...
 <span class="hljs-meta">@Autowired</span>
 <span class="hljs-keyword">private</span> SimpleJdbcMapper sjm;
...

 Product product = <span class="hljs-keyword">new</span> Product();
 product.setName(<span class="hljs-string1">&quot;some product name&quot;</span>);
 product.setPrice(<span class="hljs-number">10.25</span>);
 product.setAvailableDate(LocalDateTime.now());
 
 <span class="hljs-comment">// because id type is AUTO_GENERATED its value will be assigned on insert.</span>
 sjm.insert(product); 

 <span class="hljs-comment">// find by id</span>
 product = sjm.findById(Product.class, product.getId());
 
 <span class="hljs-comment">// update product</span>
 product.setPrice(<span class="hljs-number">11.50</span>);
 sjm.update(product);
 
 <span class="hljs-comment">// updateSpecificProperties() updates only the specified properties passed as arguments.</span>
 <span class="hljs-comment">// Will issue an SQL update only for price.</span>
 product.setPrice(<span class="hljs-number">12.50</span>);
 sjm.updateSpecificProperties(product, <span class="hljs-string1">&quot;price&quot;</span>);
 
 <span class="hljs-comment">// find all</span>
 List&lt;Product&gt; products = sjm.findAll(Product.class);
 
 <span class="hljs-comment">// delete by object</span>
 sjm.delete(product);
 
 <span class="hljs-comment">// delete by id</span>
 sjm.delete(Product.class, <span class="hljs-number">5</span>);
 
 <span class="hljs-comment">/*
The following method gets the sql for the columns. Works well with Spring row mappers like 
BeanPropertyRowMapper(), SimplePropertyRowMapper() etc. Will create the needed column aliases 
when the column name does not match the corresponding underscore case property name.
 */</span>
 String sql = <span class="hljs-string1">&quot;SELECT &quot;</span> + sjm.getBeanFriendlySqlColumns(Product.class) +  <span class="hljs-string1">&quot; FROM product WHERE product_name = ?&quot;</span>;
 
 <span class="hljs-comment">// Using JdbcClient api for the above sql</span>
 List&lt;Product&gt; products = sjm.getJdbcClient().sql(sql).param(<span class="hljs-string1">&quot;someProductName&quot;</span>).query(Product.class).list();
 
 <span class="hljs-comment">// Using JdbcTemplate api for the above sql</span>
 List&lt;Product&gt; products sjm.getJdbcTemplate().query(sql,BeanPropertyRowMapper.newInstance(Product.class),<span class="hljs-string1">&quot;someProductName&quot;</span>);
 
 <span class="hljs-comment">// Accessing the underlying JdbcClient, JdbcTemplate and NamedParameterJdbcTemplate.</span>
 JdbcClient jdbcClient = sjm.getJdbcClient();
 JdbcTemplate jdbcTemplate = sjm.getJdbcTemplate();
 NamedParameterJdbcTemplate namedParameterJdbcTemplate = sjm.getNamedParameterJdbcTemplate();
 
 <span class="hljs-comment">// See logging section for details to view the SQL</span>
 
 <span class="hljs-comment">// See troubleshooting section if you have issues with the initial setup.</span>
 
 <span class="hljs-comment">// Thats all folks. Happy coding!!!</span></code></pre><h2 id="jdk-and-spring-version-requirements"><a class="header-link" href="#jdk-and-spring-version-requirements"></a>JDK and Spring version requirements</h2>
<p>JDK <strong>21+</strong></p>
<p>Spring framework <strong>6.1.4+</strong> or SpringBoot <strong>3.2.3+</strong></p>
<h2 id="maven-coordinates"><a class="header-link" href="#maven-coordinates"></a>Maven coordinates</h2>
<pre class="hljs"><code> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.github.spring-jdbc-crud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>simplejdbcmapper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h2 id="spring-bean-configuration-for-simplejdbcmapper"><a class="header-link" href="#spring-bean-configuration-for-simplejdbcmapper"></a>Spring bean configuration for SimpleJdbcMapper</h2>
<p>SimpleJdbcMapper should be prepared in a Spring application context and given to services as a bean reference. It caches table meta-data etc.</p>
<p><strong>Note: An instance of SimpleJdbcMapper is thread safe</strong></p>
<p>Examples for different databases below. Depending on the versions of springboot/database/driver, there could be some differences to the properties. The properties are similar to datasource properties used to configure Spring JdbcClient/JdbcTemplate.</p>
<p><strong>PostgreSQL</strong></p>
<pre class="hljs"><code># application.properties
spring.datasource.jdbc-url=jdbc:postgresql:<span class="hljs-comment">//HOST:PORT/SCHEMA_NAME</span>
spring.datasource.username=username
spring.datasource.password=password
spring.datasource.driver-<span class="hljs-class"><span class="hljs-keyword">class</span>-<span class="hljs-title">name</span>=<span class="hljs-title">org</span>.<span class="hljs-title">postgresql</span>.<span class="hljs-title">Driver</span></span>
...

  <span class="hljs-comment">// DataSource properties are read from application.properties.</span>
  <span class="hljs-meta">@Bean</span>
  <span class="hljs-meta">@ConfigurationProperties(prefix = <span class="hljs-meta-string">&quot;spring.datasource&quot;</span>)</span>
  <span class="hljs-keyword">public</span> DataSource sqlDataSource() {
    <span class="hljs-keyword">return</span> DataSourceBuilder.create().build();
  }

 <span class="hljs-meta">@Bean</span>
  <span class="hljs-keyword">public</span> SimpleJdbcMapper simpleJdbcMapper(DataSource dataSource) {
    <span class="hljs-keyword">return</span> new SimpleJdbcMapper(dataSource, SCHEMA_NAME);
  }
  </code></pre><p><strong>MySQL</strong></p>
<pre class="hljs"><code># application.properties
spring.datasource.jdbc-url=jdbc:mysql:<span class="hljs-comment">//HOST:PORT/DATABASE_NAME</span>
spring.datasource.username=username
spring.datasource.password=password
spring.datasource.driver-<span class="hljs-class"><span class="hljs-keyword">class</span>-<span class="hljs-title">name</span>=<span class="hljs-title">com</span>.<span class="hljs-title">mysql</span>.<span class="hljs-title">cj</span>.<span class="hljs-title">jdbc</span>.<span class="hljs-title">Driver</span></span>
...

  <span class="hljs-comment">// DataSource properties are read from application.properties.</span>
  <span class="hljs-meta">@Bean</span>
  <span class="hljs-meta">@ConfigurationProperties(prefix = <span class="hljs-meta-string">&quot;spring.datasource&quot;</span>)</span>
  <span class="hljs-keyword">public</span> DataSource sqlDataSource() {
    <span class="hljs-keyword">return</span> DataSourceBuilder.create().build();
  }

 <span class="hljs-meta">@Bean</span>
  <span class="hljs-keyword">public</span> SimpleJdbcMapper simpleJdbcMapper(DataSource dataSource) {
    <span class="hljs-keyword">return</span> new SimpleJdbcMapper(dataSource, <span class="hljs-literal">null</span>, DATABASE_NAME); <span class="hljs-comment">// For mysql, database is synonymous with catalog</span>
  }
</code></pre><p><strong>Oracle</strong></p>
<pre class="hljs"><code># application.properties
spring.datasource.jdbc-url=jdbc:oracle:thin:<span class="hljs-meta">@HOST</span>:PORT/SERVICE_NAME
spring.datasource.username=username
spring.datasource.password=password
spring.datasource.driver-<span class="hljs-class"><span class="hljs-keyword">class</span>-<span class="hljs-title">name</span>=<span class="hljs-title">oracle</span>.<span class="hljs-title">jdbc</span>.<span class="hljs-title">driver</span>.<span class="hljs-title">OracleDriver</span></span>
...

  <span class="hljs-comment">// DataSource properties are read from application.properties.</span>
  <span class="hljs-meta">@Bean</span>
  <span class="hljs-meta">@ConfigurationProperties(prefix = <span class="hljs-meta-string">&quot;spring.datasource&quot;</span>)</span>
  <span class="hljs-keyword">public</span> DataSource sqlDataSource() {
    <span class="hljs-keyword">return</span> DataSourceBuilder.create().build();
  }
  
 <span class="hljs-meta">@Bean</span>
  <span class="hljs-keyword">public</span> SimpleJdbcMapper simpleJdbcMapper(DataSource dataSource) {   
   <span class="hljs-keyword">return</span> new SimpleJdbcMapper(dataSource, SCHEMA_NAME);
  }
</code></pre><p><strong>SQLServer</strong></p>
<pre class="hljs"><code># application.properties
spring.datasource.jdbc-url=jdbc:sqlserver:<span class="hljs-comment">//HOST:PORT;databaseName=CATALOG_NAME;encrypt=true;trustServerCertificate=true;</span>
spring.datasource.username=username
spring.datasource.password=password
spring.datasource.driver-<span class="hljs-class"><span class="hljs-keyword">class</span>-<span class="hljs-title">name</span>=<span class="hljs-title">com</span>.<span class="hljs-title">microsoft</span>.<span class="hljs-title">sqlserver</span>.<span class="hljs-title">jdbc</span>.<span class="hljs-title">SQLServerDriver</span></span>
...

  <span class="hljs-comment">// DataSource properties are read from application.properties.</span>
  <span class="hljs-meta">@Bean</span>
  <span class="hljs-meta">@ConfigurationProperties(prefix = <span class="hljs-meta-string">&quot;spring.datasource&quot;</span>)</span>
  <span class="hljs-keyword">public</span> DataSource sqlDataSource() {
    <span class="hljs-keyword">return</span> DataSourceBuilder.create().build();
  }
  
 <span class="hljs-meta">@Bean</span>
  <span class="hljs-keyword">public</span> SimpleJdbcMapper simpleJdbcMapper(DataSource dataSource) {
    <span class="hljs-keyword">return</span> new SimpleJdbcMapper(dataSource, SCHEMA_NAME);
  }
  </code></pre><h2 id="configuring-a-conversionservice"><a class="header-link" href="#configuring-a-conversionservice"></a>Configuring a ConversionService</h2>
<p>By default SimpleJdbcMapper does not use a conversion service. If your java property types are mapped appropriately to the database column data type a ConversionService is not required. Having said that if you are getting data conversion errors you can configure Spring&#39;s DefaultConversionService (or your own custom ConversionService). Spring&#39;s DefaultConversionService should meet most use cases.</p>
<pre class="hljs"><code>SimpleJdbcMapper sjm = <span class="hljs-keyword">new</span> <span class="hljs-constructor">SimpleJdbcMapper(<span class="hljs-params">dataSource</span>)</span>;
sjm.set<span class="hljs-constructor">ConversionService(DefaultConversionService.<span class="hljs-params">getSharedInstance</span>()</span>);
return sjm;</code></pre><h2 id="annotations"><a class="header-link" href="#annotations"></a>Annotations</h2>
<p><strong>@Table</strong></p>
<p>Required class level annotation. The table or view should exist in database. The schema/catalog attributes set with @Table will override corresponding values 
on the SimpleJdbcMapper() constructor. </p>
<pre class="hljs"><code>
<span class="hljs-meta">@Table(name=&quot;product&quot;)</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span> </span>{
  ...
}

<span class="hljs-meta">@Table(name=&quot;product&quot;, schema=&quot;someSchemaName&quot;)</span> 
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span> </span>{
  ...
}

<span class="hljs-meta">@Table(name=&quot;product&quot;, catalog=&quot;someCatalogName&quot;)</span>  <span class="hljs-comment">// for mysql, database name is synonymous with catalog name </span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span> </span>{
  ...
}

<span class="hljs-meta">@Table(name=&quot;product&quot;, catalog=&quot;someCatalogName&quot;, schema=&quot;someSchemaName&quot;)</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span> </span>{
  ...
}
</code></pre><p><strong>@Id</strong></p>
<p>There are 2 forms of usage for this.</p>
<ul class="list">
<li><strong>auto generated id usage</strong></li>
</ul>
<pre class="hljs"><code>
<span class="hljs-meta">@Table(name=&quot;product&quot;)</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span> </span>{
 <span class="hljs-meta">@Id(type=IdType.AUTO_GENERATED)</span>
 <span class="hljs-keyword">private</span> Integer productId;
  ...
}
</code></pre><p>After a successful insert() operation the productId property will be populated with the new id.</p>
<ul class="list">
<li><strong>NON auto generated id usage</strong></li>
</ul>
<pre class="hljs"><code>
<span class="hljs-meta">@Table(name=&quot;customer&quot;)</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span> </span>{
 <span class="hljs-meta">@Id</span>
 <span class="hljs-keyword">private</span> Integer id;
  ...
}</code></pre><p>In this case you will have to manually set the id value before invoking insert()  </p>
<p><strong>@Column</strong></p>
<p>Properties that need be persisted to the database will need @Column annotation unless the property is already annotated with one of the other annotations (@Id, @Version, @CreatedOn @CreatedBy @UpdatedOn @UpdatedBy). @Column can be used with the other annotations to map to a different column name.</p>
<p>The two ways to use it:</p>
<p>@Column<br>This will map the property to a column using the default naming convention of camel case to underscore case. For example property &#39;lastName&#39; will map to column &#39;last_name&#39; by default</p>
<p>@Column(name=&quot;somecolumnname&quot;)<br>This will map the property to the column specified by name attribute.   </p>
<p><strong>@Version</strong></p>
<p>This annotation is used for optimistic locking. It has to be of type Integer.
Will be set to 1 when record is created and will incremented on updates. On updates if the version is stale an OptimisticLockingException will be thrown.  @Column annotation can be used with this to map to a different column name.</p>
<p><strong>@CreatedOn</strong></p>
<p>When record is created the property will be set. It has to be of type LocalDateTime. @Column annotation can be used with this to map to a different column name.</p>
<p><strong>@UpdatedOn</strong></p>
<p>On updates  the property will be set. It has to be of type LocalDateTime. @Column annotation can be used with this to map to a different column name.</p>
<p><strong>@CreatedBy</strong></p>
<p>If RecordOperatorResolver is implemented and configured with SimpleJdbcMapper the value will be set to value returned by implementation when the record is created. Without configuration no values will be set. The type returned should match the type of the property. @Column annotation can be used with this to map to a different column name.</p>
<p><strong>@UpdatedBy</strong></p>
<p>If RecordOperatorResolver is implemented and configured with SimpleJdbcMapper the value will be set to value returned by implementation when the record is updated. Without configuration no values will be set. The type returned should match the type of the property. @Column annotation can be used with this to map to a different column name.</p>
<p> Annotation examples:</p>
<pre class="hljs"><code>
<span class="hljs-meta">@Table(name=&quot;product&quot;)</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span> </span>{

 <span class="hljs-meta">@Id(type=IdType.AUTO_GENERATED)</span>
 <span class="hljs-keyword">private</span> Integer productId; 
 
 <span class="hljs-meta">@Column(name=&quot;product_name&quot;)</span>
 <span class="hljs-keyword">private</span> String name;              <span class="hljs-comment">// maps to product_name column</span>
 
 <span class="hljs-meta">@Column</span>
 <span class="hljs-keyword">private</span> String productDescription <span class="hljs-comment">// defaults to column product_description </span>
 
 <span class="hljs-meta">@CreatedOn</span> 
 <span class="hljs-keyword">private</span> LocalDateTime createdTimestamp;  <span class="hljs-comment">// defaults to column created_timestamp. Property type should be LocalDateTime </span>
  
 <span class="hljs-meta">@CreatedBy</span>
 <span class="hljs-keyword">private</span> String createdByUser;     <span class="hljs-comment">// defaults to column created_by_user. </span>
                                   <span class="hljs-comment">// Property type should match return value of implementation of RecordOperatorResolver.  </span>
  
 <span class="hljs-meta">@UpdatedOn</span>
 <span class="hljs-keyword">private</span> LocalDateTime updatedAt;  <span class="hljs-comment">// defaults to column updated_at. Property type should be LocalDateTime  </span>
 
 <span class="hljs-meta">@Column(name=&quot;last_update_user&quot;)</span>
 <span class="hljs-meta">@UpdatedBy</span>
 <span class="hljs-keyword">private</span> String updatedBy;         <span class="hljs-comment">// maps to column last_update_user. </span>
                                   <span class="hljs-comment">// Property type should match return value of implementation of RecordOperatorResolver.</span>
   
 <span class="hljs-meta">@Version</span>
 <span class="hljs-keyword">private</span> Integer version;          <span class="hljs-comment">// defaults to column version, </span>
                                   <span class="hljs-comment">// Property type should be Integer. Used for optimistic locking.</span>
                                   <span class="hljs-comment">// Gets incremented every successful update.</span>
  
}</code></pre><h2 id="configuration-for-auto-assigning-createdby-and-updateby"><a class="header-link" href="#configuration-for-auto-assigning-createdby-and-updateby"></a>Configuration for auto assigning @CreatedBy and @UpdateBy</h2>
<pre class="hljs"><code>
<span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> SimpleJdbcMapper <span class="hljs-title">simpleJdbcMapper</span><span class="hljs-params">(DataSource dataSource)</span> </span>{
    SimpleJdbcMapper simpleJdbcMapper = <span class="hljs-keyword">new</span> SimpleJdbcMapper(dataSource);
    simpleJdbcMapper.setRecordOperatorResolver(<span class="hljs-keyword">new</span> YourImplementationOfInterface_RecordOperatorResolver());
    <span class="hljs-keyword">return</span> simpleJdbcMapper;
}</code></pre><h2 id="accessing-jdbcclientjdbctemplate"><a class="header-link" href="#accessing-jdbcclientjdbctemplate"></a>Accessing JdbcClient/JdbcTemplate</h2>
<pre class="hljs"><code>
 <span class="hljs-keyword">JdbcClient </span><span class="hljs-keyword">jdbcClient </span>= sjm.getJdbcClient();
 <span class="hljs-keyword">JdbcTemplate </span><span class="hljs-keyword">jdbcTemplate </span>= sjm.getJdbcTemplate();
 NamedParameterJdbcTemplate namedParameterJdbcTemplate = sjm.getNamedParameterJdbcTemplate();</code></pre><h2 id="logging"><a class="header-link" href="#logging"></a>Logging</h2>
<p>Uses the same logging configurations as Spring. In application.properties:</p>
<pre class="hljs"><code>
<span class="hljs-comment"># log the SQL</span>
<span class="hljs-attr">logging.level.org.springframework.jdbc.core.JdbcTemplate</span>=TRACE

<span class="hljs-comment"># need this to log the INSERT statements</span>
<span class="hljs-attr">logging.level.org.springframework.jdbc.core.simple.SimpleJdbcInsert</span>=TRACE

<span class="hljs-comment"># log the parameters of SQL statement</span>
<span class="hljs-attr">logging.level.org.springframework.jdbc.core.StatementCreatorUtils</span>=TRACE
</code></pre><h2 id="troubleshooting"><a class="header-link" href="#troubleshooting"></a>TroubleShooting</h2>
<p>1.<strong>Connection issues:</strong></p>
<p>Try to connect to the database using Spring JdbcClient or JdbcTemplate without the SimpleJdbcMapper and issue a simple query. The datasource configuration parameters are exactly the same.</p>
<p>2.<strong>Table does not exist or a similar exception</strong></p>
<p>For <strong>MySql</strong> try setting the &#39;catalog&#39; parameter on constructor of SimpleJdbcMapper() (3rd argument) or set the &#39;catalog&#39; attribute on the @Table annotation of the object. Database name is considered the same as catalog name for mysql.</p>
<p>Example: </p>
<pre class="hljs"><code><span class="hljs-keyword">new</span> <span class="hljs-constructor">SimpleJdbcMapper(<span class="hljs-params">dataSource</span>, <span class="hljs-params">null</span>, <span class="hljs-string1">&quot;DATABASE_NAME&quot;</span>)</span>;
Or
@<span class="hljs-constructor">Table(<span class="hljs-params">name</span>=<span class="hljs-string1">&quot;sometablename&quot;</span>, <span class="hljs-params">catalog</span>=<span class="hljs-string1">&quot;DATABASE_NAME&quot;</span>)</span>;</code></pre><p>For <strong>Postgres/Oracle/Sqlserver</strong> try setting the &#39;schema&#39; parameter on constructor of SimpleJdbcMapper() (2nd argument) or set the &#39;schema&#39; attribute on the @Table annotation of the object.</p>
<pre class="hljs"><code><span class="hljs-keyword">new</span> <span class="hljs-constructor">SimpleJdbcMapper(<span class="hljs-params">dataSource</span>, <span class="hljs-string1">&quot;SCHEMA_NAME&quot;</span>)</span>;
Or
@<span class="hljs-constructor">Table(<span class="hljs-params">name</span>=<span class="hljs-string1">&quot;sometablename&quot;</span>, <span class="hljs-params">schema</span>=<span class="hljs-string1">&quot;SCHEMA_NAME&quot;</span>)</span>;</code></pre><ol start="3">
<li><strong>Data conversion errors</strong></li>
</ol>
<p>By default SimpleJdbcMapper does not use a conversion service. If your java property types are mapped appropriately to the database column data type a ConversionService is not required. Having said that if you are getting conversion errors you can configure Spring&#39;s DefaultConversionService (or your own custom ConversionService). Spring&#39;s DefaultConversionService should meet most use cases.</p>
<pre class="hljs"><code>SimpleJdbcMapper sjm = <span class="hljs-keyword">new</span> <span class="hljs-constructor">SimpleJdbcMapper(<span class="hljs-params">dataSource</span>)</span>;
sjm.set<span class="hljs-constructor">ConversionService(DefaultConversionService.<span class="hljs-params">getSharedInstance</span>()</span>);
return sjm;</code></pre><p>4.<strong>Postgres and OffsetDateTime</strong></p>
<p>  Postgres database metadata for column definition &#39;TIMESTAMP WITH TIMEZONE&#39; returns java.sql.Types.TIMESTAMP which is wrong, causing conversion failures. Do the following when configuring SimpleJdbcMapper():</p>
<pre class="hljs"><code>SimpleJdbcMapper sjm = <span class="hljs-built_in">new</span> SimpleJdbcMapper(dataSource);    
Map&lt;<span class="hljs-keyword">Class</span>&lt;?&gt;, <span class="hljs-type">Integer</span>&gt; map = <span class="hljs-built_in">new</span> HashMap&lt;&gt;();
// map OffsetDateTime <span class="hljs-keyword">to</span> the correct <span class="hljs-keyword">sql</span> <span class="hljs-keyword">Type</span>
map.put(OffsetDateTime.<span class="hljs-keyword">class</span>, java.<span class="hljs-keyword">sql</span>.<span class="hljs-keyword">Types</span>.TIMESTAMP_WITH_TIMEZONE);
sjm.setDatabaseMetaDataOverride(map);
<span class="hljs-keyword">return</span> sjm;
    </code></pre>      </div>
    </div>
  </div>

  <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script type="text/javascript" src="assets/js/bootstrap.min.js"></script>
</body>
</html>
