package io.github.simplejdbcmapper.core;

import java.sql.Types;

import org.springframework.beans.BeanWrapper;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.simple.SimpleJdbcInsert;
import org.springframework.jdbc.core.support.SqlBinaryValue;
import org.springframework.jdbc.core.support.SqlCharacterValue;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.util.Assert;

import io.github.simplejdbcmapper.exception.MapperException;

class InsertOperation {
	private final SimpleJdbcMapperSupport sjmSupport;

	// insert cache. Note that Spring SimpleJdbcInsert is thread safe.
	// Map key - class name
	// value - SimpleJdbcInsert
	private final SimpleCache<String, SimpleJdbcInsert> insertSqlCache = new SimpleCache<>();

	public InsertOperation(SimpleJdbcMapperSupport sjmSupport) {
		this.sjmSupport = sjmSupport;
	}

	public void insert(Object obj) {
		Assert.notNull(obj, "Object must not be null");
		TableMapping tableMapping = sjmSupport.getTableMapping(obj.getClass());
		BeanWrapper bw = sjmSupport.getBeanWrapper(obj);
		validateId(tableMapping, bw);
		populateAutoAssignProperties(tableMapping, bw);
		MapSqlParameterSource mapSqlParameterSource = createMapSqlParameterSource(tableMapping, bw);
		boolean foundInCache = false;
		SimpleJdbcInsert simpleJdbcInsert = insertSqlCache.get(obj.getClass().getName());
		if (simpleJdbcInsert == null) {
			simpleJdbcInsert = createNewSimpleJdbcInsert(tableMapping);
		} else {
			foundInCache = true;
		}
		if (tableMapping.isIdAutoGenerated()) {
			KeyHolder kh = simpleJdbcInsert.executeAndReturnKeyHolder(mapSqlParameterSource);
			Object generatedId = null;
			if (Number.class.isAssignableFrom(getClassFor(tableMapping.getIdPropertyClassName()))) {
				generatedId = kh.getKeyAs(Number.class);
			} else {
				generatedId = kh.getKeyAs(getClassFor(tableMapping.getIdPropertyClassName()));
			}
			bw.setPropertyValue(tableMapping.getIdPropertyName(), generatedId);
		} else {
			simpleJdbcInsert.execute(mapSqlParameterSource);
		}
		if (!foundInCache) {
			// SimpleJdbcInsert is thread safe so can be cached
			insertSqlCache.put(obj.getClass().getName(), simpleJdbcInsert);
		}
	}

	SimpleCache<String, SimpleJdbcInsert> getInsertSqlCache() {
		return insertSqlCache;
	}

	private MapSqlParameterSource createMapSqlParameterSource(TableMapping tableMapping, BeanWrapper bw) {
		MapSqlParameterSource mapSqlParameterSource = new MapSqlParameterSource();
		for (PropertyMapping propMapping : tableMapping.getPropertyMappings()) {
			int columnSqlType = propMapping.getColumnOverriddenSqlType() == null ? propMapping.getColumnSqlType()
					: propMapping.getColumnOverriddenSqlType();
			if (columnSqlType == Types.BLOB) {
				assignBlobMapSqlParameterSource(bw, mapSqlParameterSource, propMapping);
			} else if (columnSqlType == Types.CLOB) {
				assignClobMapSqlParameterSource(bw, mapSqlParameterSource, propMapping);
			} else {
				// SimpleJdbcInsert logs extra stuff when we override its internal sqltype so
				// keep it to a minimum
				if (propMapping.getColumnOverriddenSqlType() == null) {
					mapSqlParameterSource.addValue(propMapping.getColumnName(),
							bw.getPropertyValue(propMapping.getPropertyName()));
				} else {
					mapSqlParameterSource.addValue(propMapping.getColumnName(),
							bw.getPropertyValue(propMapping.getPropertyName()),
							propMapping.getColumnOverriddenSqlType());
				}
			}
		}
		return mapSqlParameterSource;
	}

	private void validateId(TableMapping tableMapping, BeanWrapper bw) {
		Object idValue = bw.getPropertyValue(tableMapping.getIdPropertyName());
		if (tableMapping.isIdAutoGenerated()) {
			if (idValue != null) {
				throw new MapperException("For insert() the property " + bw.getWrappedClass().getSimpleName() + "."
						+ tableMapping.getIdPropertyName()
						+ " has to be null since this insert is for an object whose id is auto generated");
			}
		} else {
			if (idValue == null) {
				throw new MapperException("For insert() the property " + bw.getWrappedClass().getSimpleName() + "."
						+ tableMapping.getIdPropertyName() + " must not be null since it is not an auto generated id");
			}
		}
	}

	private void populateAutoAssignProperties(TableMapping tableMapping, BeanWrapper bw) {
		if (tableMapping.hasAutoAssignProperties()) {
			PropertyMapping createdOnPropMapping = tableMapping.getCreatedOnPropertyMapping();
			if (createdOnPropMapping != null && sjmSupport.getRecordAuditedOnSupplier() != null) {
				bw.setPropertyValue(createdOnPropMapping.getPropertyName(),
						sjmSupport.getRecordAuditedOnSupplier().get());
			}
			PropertyMapping updatedOnPropMapping = tableMapping.getUpdatedOnPropertyMapping();
			if (updatedOnPropMapping != null && sjmSupport.getRecordAuditedOnSupplier() != null) {
				bw.setPropertyValue(updatedOnPropMapping.getPropertyName(),
						sjmSupport.getRecordAuditedOnSupplier().get());
			}
			PropertyMapping createdByPropMapping = tableMapping.getCreatedByPropertyMapping();
			if (createdByPropMapping != null && sjmSupport.getRecordAuditedBySupplier() != null) {
				bw.setPropertyValue(createdByPropMapping.getPropertyName(),
						sjmSupport.getRecordAuditedBySupplier().get());
			}
			PropertyMapping updatedByPropMapping = tableMapping.getUpdatedByPropertyMapping();
			if (updatedByPropMapping != null && sjmSupport.getRecordAuditedBySupplier() != null) {
				bw.setPropertyValue(updatedByPropMapping.getPropertyName(),
						sjmSupport.getRecordAuditedBySupplier().get());
			}
			PropertyMapping versionPropMapping = tableMapping.getVersionPropertyMapping();
			if (versionPropMapping != null) {
				// version property value defaults to 1 on inserts
				bw.setPropertyValue(versionPropMapping.getPropertyName(), 1);
			}
		}
	}

	private SimpleJdbcInsert createNewSimpleJdbcInsert(TableMapping tableMapping) {
		SimpleJdbcInsert jdbcInsert = new SimpleJdbcInsert(sjmSupport.getDataSource())
				.withCatalogName(tableMapping.getCatalogName()).withSchemaName(tableMapping.getSchemaName())
				.withTableName(tableMapping.getTableName());
		// need this for oracle
		jdbcInsert.includeSynonymsForTableColumnMetaData();
		if (tableMapping.isIdAutoGenerated()) {
			jdbcInsert.usingGeneratedKeyColumns(tableMapping.getIdColumnName());
		}
		return jdbcInsert;
	}

	private void assignBlobMapSqlParameterSource(BeanWrapper bw, MapSqlParameterSource mapSqlParameterSource,
			PropertyMapping propMapping) {
		if (bw.getPropertyValue(propMapping.getPropertyName()) == null) {
			mapSqlParameterSource.addValue(propMapping.getColumnName(), null);
		} else {
			mapSqlParameterSource.addValue(propMapping.getColumnName(),
					new SqlBinaryValue((byte[]) bw.getPropertyValue(propMapping.getPropertyName())), Types.BLOB);
		}
	}

	private void assignClobMapSqlParameterSource(BeanWrapper bw, MapSqlParameterSource mapSqlParameterSource,
			PropertyMapping propMapping) {
		if (bw.getPropertyValue(propMapping.getPropertyName()) == null) {
			mapSqlParameterSource.addValue(propMapping.getColumnName(), null);
		} else {
			mapSqlParameterSource.addValue(propMapping.getColumnName(),
					new SqlCharacterValue((char[]) bw.getPropertyValue(propMapping.getPropertyName())), Types.CLOB);
		}
	}

	private Class<?> getClassFor(String className) {
		try {
			return Class.forName(className);
		} catch (Exception e) {
			return null;
		}
	}

}
