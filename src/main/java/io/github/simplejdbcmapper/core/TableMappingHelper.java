package io.github.simplejdbcmapper.core;

import java.lang.reflect.Field;
import java.sql.DatabaseMetaData;
import java.sql.SQLException;
import java.sql.Types;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import org.springframework.core.annotation.AnnotationUtils;
import org.springframework.jdbc.core.metadata.TableMetaDataContext;
import org.springframework.jdbc.core.metadata.TableMetaDataProvider;
import org.springframework.jdbc.core.metadata.TableMetaDataProviderFactory;
import org.springframework.jdbc.core.metadata.TableParameterMetaData;
import org.springframework.jdbc.support.DatabaseMetaDataCallback;
import org.springframework.jdbc.support.JdbcUtils;
import org.springframework.jdbc.support.MetaDataAccessException;
import org.springframework.util.Assert;

import io.github.simplejdbcmapper.annotation.Id;
import io.github.simplejdbcmapper.annotation.IdType;
import io.github.simplejdbcmapper.annotation.Table;
import io.github.simplejdbcmapper.exception.AnnotationException;
import io.github.simplejdbcmapper.exception.MapperException;

class TableMappingHelper {
	// Map key - class name
	// value - the table mapping
	private final SimpleCache<String, TableMapping> tableMappingCache = new SimpleCache<>();

	private final AnnotationHelper annoHelper;

	private final SimpleJdbcMapperSupport sjms;

	private String databaseProductName;

	public TableMappingHelper(SimpleJdbcMapperSupport sjms) {
		this.sjms = sjms;
		this.annoHelper = new AnnotationHelper();
	}

	public TableMapping getTableMapping(Class<?> clazz) {
		Assert.notNull(clazz, "clazz must not be null");
		TableMapping tableMapping = tableMappingCache.get(clazz.getName());
		if (tableMapping == null) {
			Table tableAnnotation = annoHelper.getTableAnnotation(clazz);
			String tableName = tableAnnotation.name();
			String catalog = getCatalogForTable(tableAnnotation);
			String schema = getSchemaForTable(tableAnnotation);
			validateMetaDataConfig(catalog, schema);
			List<Field> fields = getAllFields(clazz);
			IdPropertyInfo idPropertyInfo = getIdPropertyInfo(clazz, fields);
			// key:column name, value: TableParameterMetaData
			Map<String, TableParameterMetaData> columnNameToTpmd = getTableParameterMetadataList(tableName, schema,
					catalog, clazz).stream().collect(Collectors.toMap(o -> o.getParameterName(), o -> o));
			// key:propertyName, value:PropertyMapping. LinkedHashMap to maintain order of
			// properties
			Map<String, PropertyMapping> propNameToPropertyMapping = new LinkedHashMap<>();
			for (Field field : fields) {
				// process column annotation always first
				annoHelper.processColumnAnnotation(field, tableName, propNameToPropertyMapping, columnNameToTpmd);
				annoHelper.processIdAnnotation(field, tableName, propNameToPropertyMapping, columnNameToTpmd);
				annoHelper.processVersionAnnotation(field, tableName, propNameToPropertyMapping, columnNameToTpmd);
				annoHelper.processCreatedOnAnnotation(field, tableName, propNameToPropertyMapping, columnNameToTpmd);
				annoHelper.processUpdatedOnAnnotation(field, tableName, propNameToPropertyMapping, columnNameToTpmd);
				annoHelper.processCreatedByAnnotation(field, tableName, propNameToPropertyMapping, columnNameToTpmd);
				annoHelper.processUpdatedByAnnotation(field, tableName, propNameToPropertyMapping, columnNameToTpmd);
			}
			List<PropertyMapping> propertyMappings = new ArrayList<>(propNameToPropertyMapping.values());
			annoHelper.validateAnnotations(propertyMappings, clazz);
			processOverridesForSqlType(propertyMappings);
			tableMapping = new TableMapping(clazz, tableName, schema, catalog, idPropertyInfo, propertyMappings);
			tableMappingCache.put(clazz.getName(), tableMapping);
		}
		return tableMapping;
	}

	public String getCommonDatabaseName() {
		return JdbcUtils.commonDatabaseName(getDatabaseProductName());
	}

	public SimpleCache<String, TableMapping> getTableMappingCache() {
		return tableMappingCache;
	}

	// gets all unique fields including from super classes.
	private List<Field> getAllFields(Class<?> clazz) {
		List<Field> fields = getAllFieldsInternal(clazz);
		// there could be duplicate fields due to super classes. Get unique fields list
		// by name
		Set<String> set = new LinkedHashSet<>();
		return fields.stream().filter(p -> set.add(p.getName())).toList();
	}

	private IdPropertyInfo getIdPropertyInfo(Class<?> clazz, List<Field> fields) {
		Id idAnnotation = null;
		String idPropertyName = null;
		boolean isIdAutoGenerated = false;
		for (Field field : fields) {
			idAnnotation = AnnotationUtils.findAnnotation(field, Id.class);
			if (idAnnotation != null) {
				if (field.getType().isPrimitive()) {
					throw new AnnotationException(
							clazz.getSimpleName() + "." + idPropertyName + " is an id and cannot be a primitive type.");
				}
				idPropertyName = field.getName();
				if (idAnnotation.type() == IdType.AUTO_GENERATED) {
					isIdAutoGenerated = true;
				}
				break;
			}
		}
		if (idAnnotation == null) {
			throw new AnnotationException(
					"@Id annotation not found in class " + clazz.getSimpleName() + " . It is required");
		}
		return new IdPropertyInfo(clazz, idPropertyName, isIdAutoGenerated);
	}

	private TableMetaDataContext createNewTableMetaDataContext(String table, String schema, String catalog) {
		TableMetaDataContext tableMetaDataContext = new TableMetaDataContext();
		tableMetaDataContext.setTableName(table);
		tableMetaDataContext.setSchemaName(schema);
		tableMetaDataContext.setCatalogName(catalog);
		tableMetaDataContext.setAccessTableColumnMetaData(true);
		tableMetaDataContext.setOverrideIncludeSynonymsDefault(true);
		return tableMetaDataContext;
	}

	// get all fields including fields in super classes.
	private List<Field> getAllFieldsInternal(Class<?> clazz) {
		if (clazz == null) {
			return Collections.emptyList();
		}
		List<Field> result = new ArrayList<>(getAllFieldsInternal(clazz.getSuperclass()));
		List<Field> fields = Arrays.stream(clazz.getDeclaredFields()).toList();
		result.addAll(0, fields);
		return result;
	}

	private List<TableParameterMetaData> getTableParameterMetadataList(String tableName, String schema, String catalog,
			Class<?> clazz) {
		if (InternalUtils.isBlank(tableName)) {
			throw new IllegalArgumentException("tableName must not be blank");
		}
		TableMetaDataContext tableMetaDataContext = createNewTableMetaDataContext(tableName, schema, catalog);
		TableMetaDataProvider provider = TableMetaDataProviderFactory.createMetaDataProvider(sjms.getDataSource(),
				tableMetaDataContext);
		List<TableParameterMetaData> tpmdList = provider.getTableParameterMetaData();
		if (InternalUtils.isEmpty(tpmdList)) {
			throw new AnnotationException(getTableMetaDataNotFoundErrMsg(clazz, tableName, schema, catalog));
		}
		return tpmdList;
	}

	private String getTableMetaDataNotFoundErrMsg(Class<?> clazz, String tableName, String schema, String catalog) {
		String errMsg = "Unable to locate meta-data for table '" + tableName + "'";
		if (schema != null && catalog != null) {
			errMsg += " in schema " + schema + " and catalog " + catalog;
		} else {
			if (schema != null) {
				errMsg += " in schema " + schema;
			}
			if (catalog != null) {
				errMsg += " in catalog/database " + catalog;
			}
		}
		errMsg += " for class " + clazz.getSimpleName();
		return errMsg;
	}

	private String getDatabaseProductName() {
		// No side effects even if there is thread contention and it gets set more than
		// once
		if (databaseProductName != null) {
			return databaseProductName;
		} else {
			synchronized (this) {
				if (databaseProductName == null) {
					try {
						databaseProductName = JdbcUtils.extractDatabaseMetaData(sjms.getDataSource(),
								new DatabaseMetaDataCallback<String>() {
									public String processMetaData(DatabaseMetaData dbMetaData)
											throws SQLException, MetaDataAccessException {
										return dbMetaData.getDatabaseProductName() == null ? ""
												: dbMetaData.getDatabaseProductName();
									}
								});
					} catch (Exception e) {
						throw new MapperException(e);
					}
				}
				return databaseProductName;
			}
		}
	}

	private String getCatalogForTable(Table tableAnnotation) {
		return InternalUtils.isBlank(tableAnnotation.catalog()) ? sjms.getCatalogName() : tableAnnotation.catalog();
	}

	private String getSchemaForTable(Table tableAnnotation) {
		return InternalUtils.isBlank(tableAnnotation.schema()) ? sjms.getSchemaName() : tableAnnotation.schema();
	}

	private void validateMetaDataConfig(String catalog, String schema) {
		String commonDatabaseName = JdbcUtils.commonDatabaseName(getDatabaseProductName());
		if ("mysql".equalsIgnoreCase(commonDatabaseName) && InternalUtils.isNotEmpty(schema)) {
			throw new MapperException(commonDatabaseName
					+ ": When creating SimpleJdbcMapper() if you are using 'schema' (argument 2) use 'catalog' (argument 3) instead."
					+ " If you are using the @Table annotation use the 'catalog' attribue instead of 'schema' attribute");
		}
		if ("oracle".equalsIgnoreCase(commonDatabaseName) && InternalUtils.isNotEmpty(catalog)) {
			throw new MapperException(commonDatabaseName
					+ ": When creating SimpleJdbcMapper() if you are using the 'catalog' (argument 3) use 'schema' (argument 2) instead."
					+ " If you are using the @Table annotation use the 'schema' attribue instead of 'catalog' attribute");
		}
	}

	private void processOverridesForSqlType(List<PropertyMapping> propertyMappings) {
		if (sjms.isEnableOffsetDateTimeSqlTypeAsTimestampWithTimeZone()) {
			for (PropertyMapping pm : propertyMappings) {
				if (getClassFor(pm.getPropertyClassName()) != null
						&& OffsetDateTime.class.isAssignableFrom(getClassFor(pm.getPropertyClassName()))) {
					pm.setColumnOverriddenSqlType(Types.TIMESTAMP_WITH_TIMEZONE);
				}
			}
		}
	}

	private Class<?> getClassFor(String className) {
		try {
			return Class.forName(className);
		} catch (Exception e) {
			return null;
		}
	}
}
