package io.github.simplejdbcmapper.core;

import java.lang.reflect.Field;
import java.sql.DatabaseMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.sql.DataSource;

import org.springframework.core.annotation.AnnotationUtils;
import org.springframework.jdbc.core.metadata.TableMetaDataContext;
import org.springframework.jdbc.core.metadata.TableMetaDataProvider;
import org.springframework.jdbc.core.metadata.TableMetaDataProviderFactory;
import org.springframework.jdbc.core.metadata.TableParameterMetaData;
import org.springframework.jdbc.support.DatabaseMetaDataCallback;
import org.springframework.jdbc.support.JdbcUtils;
import org.springframework.jdbc.support.MetaDataAccessException;
import org.springframework.util.Assert;
import org.springframework.util.ObjectUtils;
import org.springframework.util.StringUtils;

import io.github.simplejdbcmapper.annotation.Id;
import io.github.simplejdbcmapper.annotation.IdType;
import io.github.simplejdbcmapper.annotation.Table;
import io.github.simplejdbcmapper.exception.AnnotationException;
import io.github.simplejdbcmapper.exception.MapperException;

class TableMappingProvider {
	private final DataSource dataSource;

	private final String schemaName;

	private final String catalogName;

	// Map key - class name
	// value - the table mapping
	private final SimpleCache<String, TableMapping> tableMappingCache = new SimpleCache<>();

	private final AnnotationProcessor ap;

	private String databaseProductName;

	public TableMappingProvider(DataSource dataSource, String schemaName, String catalogName) {
		this.dataSource = dataSource;
		this.schemaName = schemaName;
		this.catalogName = catalogName;
		this.ap = new AnnotationProcessor();
	}

	TableMapping getTableMapping(Class<?> clazz) {
		Assert.notNull(clazz, "clazz must not be null");
		TableMapping tableMapping = tableMappingCache.get(clazz.getName());
		if (tableMapping == null) {
			Table tableAnnotation = ap.getTableAnnotation(clazz);
			String tableName = tableAnnotation.name();
			String catalog = getCatalogForTable(tableAnnotation);
			String schema = getSchemaForTable(tableAnnotation);
			validateMetaDataConfig(catalog, schema);
			List<Field> fields = getAllFields(clazz);
			IdPropertyInfo idPropertyInfo = getIdPropertyInfo(clazz, fields);
			List<TableParameterMetaData> tpmdList = getTableParameterMetaDataList(tableName, schema, catalog);
			if (ObjectUtils.isEmpty(tpmdList)) {
				throw new MapperException(getTableMetaDataNotFoundErrMsg(clazz, tableName, schema, catalog));
			}
			// key:column name, value: TableParameterMetaData
			Map<String, TableParameterMetaData> columnNameToTpmd = new HashMap<>();
			for (TableParameterMetaData tpmd : tpmdList) {
				columnNameToTpmd.put(InternalUtils.toLowerCase(tpmd.getParameterName()), tpmd);
			}
			// key:propertyName, value:PropertyMapping. LinkedHashMap to maintain order of
			// properties
			Map<String, PropertyMapping> propNameToPropertyMapping = new LinkedHashMap<>();
			for (Field field : fields) {
				// process column annotation always first
				ap.processColumnAnnotation(field, tableName, propNameToPropertyMapping, columnNameToTpmd);
				ap.processIdAnnotation(field, tableName, propNameToPropertyMapping, columnNameToTpmd);
				ap.processVersionAnnotation(field, tableName, propNameToPropertyMapping, columnNameToTpmd);
				ap.processCreatedOnAnnotation(field, tableName, propNameToPropertyMapping, columnNameToTpmd);
				ap.processUpdatedOnAnnotation(field, tableName, propNameToPropertyMapping, columnNameToTpmd);
				ap.processCreatedByAnnotation(field, tableName, propNameToPropertyMapping, columnNameToTpmd);
				ap.processUpdatedByAnnotation(field, tableName, propNameToPropertyMapping, columnNameToTpmd);
			}
			List<PropertyMapping> propertyMappings = new ArrayList<>(propNameToPropertyMapping.values());
			ap.validateAnnotations(propertyMappings, clazz);
			tableMapping = new TableMapping(clazz, tableName, schema, catalog, idPropertyInfo, propertyMappings);
			tableMappingCache.put(clazz.getName(), tableMapping);
		}
		return tableMapping;
	}

	SimpleCache<String, TableMapping> getTableMappingCache() {
		return tableMappingCache;
	}

	// gets all unique fields including from super classes.
	private List<Field> getAllFields(Class<?> clazz) {
		List<Field> fields = getAllFieldsInternal(clazz);
		// there could be duplicate fields due to super classes. Get unique fields list
		// by name
		Set<String> set = new HashSet<>();
		return fields.stream().filter(p -> set.add(p.getName())).toList();
	}

	private IdPropertyInfo getIdPropertyInfo(Class<?> clazz, List<Field> fields) {
		Id idAnnotation = null;
		String idPropertyName = null;
		boolean isIdAutoGenerated = false;
		for (Field field : fields) {
			idAnnotation = AnnotationUtils.findAnnotation(field, Id.class);
			if (idAnnotation != null) {
				if (field.getType().isPrimitive()) {
					throw new AnnotationException(
							clazz.getSimpleName() + "." + idPropertyName + " is an id and cannot be a primitive type.");
				}
				idPropertyName = field.getName();
				if (idAnnotation.type() == IdType.AUTO_GENERATED) {
					isIdAutoGenerated = true;
				}
				break;
			}
		}
		if (idAnnotation == null) {
			throw new AnnotationException(
					"@Id annotation not found in class " + clazz.getSimpleName() + " . It is required");
		}
		return new IdPropertyInfo(clazz, idPropertyName, isIdAutoGenerated);
	}

	// get all fields including fields in super classes.
	private List<Field> getAllFieldsInternal(Class<?> clazz) {
		if (clazz == null) {
			return Collections.emptyList();
		}
		List<Field> result = new ArrayList<>(getAllFieldsInternal(clazz.getSuperclass()));
		List<Field> fields = Arrays.stream(clazz.getDeclaredFields()).toList();
		result.addAll(0, fields);
		return result;
	}

	private List<TableParameterMetaData> getTableParameterMetaDataList(String tableName, String schema,
			String catalog) {
		if (!StringUtils.hasText(tableName)) {
			throw new IllegalArgumentException("tableName must not be blank");
		}
		TableMetaDataContext tableMetaDataContext = createNewTableMetaDataContext(tableName, schema, catalog);
		TableMetaDataProvider provider = TableMetaDataProviderFactory.createMetaDataProvider(dataSource,
				tableMetaDataContext);
		return provider.getTableParameterMetaData();
	}

	private TableMetaDataContext createNewTableMetaDataContext(String table, String schema, String catalog) {
		TableMetaDataContext tableMetaDataContext = new TableMetaDataContext();
		tableMetaDataContext.setTableName(table);
		tableMetaDataContext.setSchemaName(schema);
		tableMetaDataContext.setCatalogName(catalog);
		tableMetaDataContext.setAccessTableColumnMetaData(true);
		tableMetaDataContext.setOverrideIncludeSynonymsDefault(true);
		return tableMetaDataContext;
	}

	private String getTableMetaDataNotFoundErrMsg(Class<?> clazz, String tableName, String schema, String catalog) {
		String errMsg = "Unable to locate meta-data for table '" + tableName + "'";
		if (schema != null && catalog != null) {
			errMsg += " in schema " + schema + " and catalog " + catalog;
		} else {
			if (schema != null) {
				errMsg += " in schema " + schema;
			}
			if (catalog != null) {
				errMsg += " in catalog/database " + catalog;
			}
		}
		errMsg += " for class " + clazz.getSimpleName();
		return errMsg;
	}

	private String getCatalogForTable(Table tableAnnotation) {
		return StringUtils.hasText(tableAnnotation.catalog()) ? tableAnnotation.catalog() : catalogName;
	}

	private String getSchemaForTable(Table tableAnnotation) {
		return StringUtils.hasText(tableAnnotation.schema()) ? tableAnnotation.schema() : schemaName;
	}

	private void validateMetaDataConfig(String catalog, String schema) {
		String commonDatabaseName = JdbcUtils.commonDatabaseName(getDatabaseProductName());
		if ("mysql".equalsIgnoreCase(commonDatabaseName) && StringUtils.hasText(schema)) {
			throw new MapperException(commonDatabaseName
					+ ": When creating SimpleJdbcMapper() if you are using 'schema' (argument 2) use 'catalog' (argument 3) instead."
					+ " If you are using the @Table annotation use the 'catalog' attribue instead of 'schema' attribute");
		}
		if ("oracle".equalsIgnoreCase(commonDatabaseName) && StringUtils.hasText(catalog)) {
			throw new MapperException(commonDatabaseName
					+ ": When creating SimpleJdbcMapper() if you are using the 'catalog' (argument 3) use 'schema' (argument 2) instead."
					+ " If you are using the @Table annotation use the 'schema' attribue instead of 'catalog' attribute");
		}
	}

	private String getDatabaseProductName() {
		// No side effects even if there is thread contention and it gets set more than
		// once
		if (databaseProductName != null) {
			return databaseProductName;
		} else {
			try {
				databaseProductName = JdbcUtils.extractDatabaseMetaData(dataSource,
						new DatabaseMetaDataCallback<String>() {
							public String processMetaData(DatabaseMetaData dbMetaData)
									throws SQLException, MetaDataAccessException {
								return dbMetaData.getDatabaseProductName() == null ? ""
										: dbMetaData.getDatabaseProductName();
							}
						});
			} catch (Exception e) {
				throw new MapperException(e);
			}
		}
		return databaseProductName;
	}
}
