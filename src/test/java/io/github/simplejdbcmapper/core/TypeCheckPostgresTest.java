package io.github.simplejdbcmapper.core;

import static org.junit.jupiter.api.Assertions.assertArrayEquals;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.math.BigDecimal;
import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.OffsetDateTime;
import java.util.Date;
import java.util.UUID;

import org.junit.jupiter.api.Assumptions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit.jupiter.SpringExtension;

import io.github.simplejdbcmapper.model.StatusEnum;
import io.github.simplejdbcmapper.model.TypeCheckPostgres;
import io.github.simplejdbcmapper.model.UuidTable;

@SpringBootTest
@ExtendWith(SpringExtension.class)
class TypeCheckPostgresTest {

	@Value("${spring.datasource.driver-class-name}")
	private String jdbcDriver;

	@Autowired
	private SimpleJdbcMapper sjm;

	@BeforeEach
	void beforeMethod() {
		// tests will only run if postgres
		if (!jdbcDriver.contains("postgres")) {
			Assumptions.assumeTrue(false);
		}
	}

	@Test
	void insert_uuidAutoGeneratedId_success() {
		UuidTable model = new UuidTable();
		model.setData("bbb");

		sjm.insert(model);

		assertNotNull(model.getId());
	}

	@Test
	void insert_TypeCheckPostgresTest() {
		TypeCheckPostgres iObj = new TypeCheckPostgres();

		var localDateVal = LocalDate.now();
		iObj.setLocalDateData(localDateVal);

		var dateVal = new Date();
		iObj.setJavaUtilDateData(dateVal);

		var localDateTimeVal = LocalDateTime.now();
		iObj.setLocalDateTimeData(localDateTimeVal);

		var bigDecimalVal = new BigDecimal("10.23");
		iObj.setBigDecimalData(bigDecimalVal);

		iObj.setBooleanVal(true);

		iObj.setImage(new byte[] { 10, 20, 30 });

		var timestampVal = new Date();
		iObj.setJavaUtilDateTsData(timestampVal);

		iObj.setStatus(StatusEnum.OPEN);

		UUID uuidVal = UUID.randomUUID();
		iObj.setSomeUuid(uuidVal);

		var offsetVal = OffsetDateTime.now();
		iObj.setOffsetDateTimeData(offsetVal);

		sjm.insert(iObj);

		TypeCheckPostgres tc = sjm.findById(TypeCheckPostgres.class, iObj.getId());

		SimpleDateFormat fmt = new SimpleDateFormat("yyyyMMdd");
		assertEquals(localDateVal, tc.getLocalDateData());

		assertEquals(fmt.format(dateVal), fmt.format(tc.getJavaUtilDateData()));

		assertEquals(localDateTimeVal, tc.getLocalDateTimeData());

		assertEquals(0, tc.getBigDecimalData().compareTo(iObj.getBigDecimalData()));

		assertArrayEquals(iObj.getImage(), tc.getImage());

		assertTrue(tc.getBooleanVal());

		SimpleDateFormat fmtTs = new SimpleDateFormat("yyyyMMdd HHmmss");

		assertEquals(fmtTs.format(timestampVal), fmtTs.format(tc.getJavaUtilDateTsData()));

		assertEquals(StatusEnum.OPEN, tc.getStatus());

		assertEquals(uuidVal, tc.getSomeUuid());

		// postgres stores TIMESTAMP WITH TIMEZONE as absolute timestamp value
		// so we have to check for instant
		assertEquals(offsetVal.toInstant(), tc.getOffsetDateTimeData().toInstant());
	}

	@Test
	void update_TypeCheckPostgresTest() {
		TypeCheckPostgres iObj = new TypeCheckPostgres();
		sjm.insert(iObj);

		TypeCheckPostgres uObj = sjm.findById(TypeCheckPostgres.class, iObj.getId());

		var localDateVal = LocalDate.now();
		uObj.setLocalDateData(localDateVal);

		var dateVal = new Date();
		uObj.setJavaUtilDateData(dateVal);

		var localDateTimeVal = LocalDateTime.now();
		uObj.setLocalDateTimeData(localDateTimeVal);

		var bigDecimalVal = new BigDecimal("10.23");
		uObj.setBigDecimalData(bigDecimalVal);

		uObj.setBooleanVal(true);

		uObj.setImage(new byte[] { 10, 20, 30 });

		var timestampVal = new Date();
		uObj.setJavaUtilDateTsData(timestampVal);

		uObj.setStatus(StatusEnum.OPEN);

		UUID uuidVal = UUID.randomUUID();
		uObj.setSomeUuid(uuidVal);

		var offsetVal = OffsetDateTime.now();
		uObj.setOffsetDateTimeData(offsetVal);

		sjm.update(uObj);

		TypeCheckPostgres tc = sjm.findById(TypeCheckPostgres.class, uObj.getId());

		SimpleDateFormat fmt = new SimpleDateFormat("yyyyMMdd");
		assertEquals(localDateVal, tc.getLocalDateData());

		assertEquals(fmt.format(dateVal), fmt.format(tc.getJavaUtilDateData()));

		assertEquals(localDateTimeVal, tc.getLocalDateTimeData());

		assertEquals(0, tc.getBigDecimalData().compareTo(tc.getBigDecimalData()));

		assertArrayEquals(tc.getImage(), tc.getImage());

		assertTrue(tc.getBooleanVal());

		SimpleDateFormat fmtTs = new SimpleDateFormat("yyyyMMdd HHmmss");

		assertEquals(fmtTs.format(timestampVal), fmtTs.format(tc.getJavaUtilDateTsData()));

		assertEquals(StatusEnum.OPEN, tc.getStatus());

		assertEquals(uuidVal, tc.getSomeUuid());

		// postgres stores TIMESTAMP WITH TIMEZONE as absolute timestamp value
		// so we have to check for instant
		assertEquals(offsetVal.toInstant(), tc.getOffsetDateTimeData().toInstant());

	}

}
